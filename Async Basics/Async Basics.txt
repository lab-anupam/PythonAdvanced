1ï¸âƒ£ First: WHY async exists (very important)
âŒ Normal (blocking) code problem
import time

def task():
    time.sleep(2)
    print("Task done")

task()
task()

â±ï¸ What happens?

First task waits 2 sec

Second task waits another 2 sec
â¡ï¸ Total time â‰ˆ 4 seconds

ğŸ’¡ CPU is idle while waiting

2ï¸âƒ£ What async REALLY means (plain English)

Async allows Python to do other work while waiting for slow operations
(like network calls, DB queries, APIs)

ğŸ“Œ Async is not for CPU-heavy work
ğŸ“Œ Async is for I/O waiting

3ï¸âƒ£ Your first async function (VERY SMALL)
async def hello():
    print("Hello async")


ğŸš¨ Important:

Calling hello() does NOT run it

It returns a coroutine object

print(hello())


Output:

<coroutine object hello at 0x...>

4ï¸âƒ£ How do we RUN async code? (asyncio)
import asyncio

async def hello():
    print("Hello async")

asyncio.run(hello())

âœ… Output
Hello async

5ï¸âƒ£ await keyword (THIS IS THE CORE)

await means:

â€œPause here and let other tasks runâ€

Example without async (blocking)
import time

def work():
    time.sleep(2)
    print("Done")

Async version (non-blocking)
import asyncio

async def work():
    await asyncio.sleep(2)
    print("Done")


ğŸš¨ await can be used ONLY inside async def

6ï¸âƒ£ Async execution flow (small example)
import asyncio

async def task1():
    print("Task1 start")
    await asyncio.sleep(2)
    print("Task1 end")

async def task2():
    print("Task2 start")
    await asyncio.sleep(2)
    print("Task2 end")

async def main():
    await task1()
    await task2()

asyncio.run(main())

â±ï¸ Output (sequential)
Task1 start
Task1 end
Task2 start
Task2 end


â±ï¸ Time â‰ˆ 4 seconds

7ï¸âƒ£ Running tasks CONCURRENTLY (this is async power)
async def main():
    await asyncio.gather(task1(), task2())

âœ… Output (order may vary)
Task1 start
Task2 start
Task1 end
Task2 end


â±ï¸ Time â‰ˆ 2 seconds

ğŸ¯ This is the async advantage

8ï¸âƒ£ Very important rule (MEMORIZE)

time.sleep() âŒ blocks event loop
asyncio.sleep() âœ… allows concurrency

9ï¸âƒ£ Async FastAPI-style function (real-world)
async def get_user(user_id):
    await asyncio.sleep(1)  # pretend DB call
    return {"id": user_id, "name": "Anupam"}


ğŸ’¡ This is exactly how:

FastAPI

Async APIs

Async microservices work

ğŸ”Ÿ Common beginner mistakes âŒ

âŒ Using time.sleep() inside async
âŒ Forgetting await
âŒ Calling async function without event loop
âŒ Thinking async = multithreading (itâ€™s not)

1ï¸âƒ£1ï¸âƒ£ Async mental model (IMPORTANT)
Task starts
   â†“
await (pause)
   â†“
event loop runs other tasks
   â†“
task resumes

1ï¸âƒ£2ï¸âƒ£ Async demo code (Expected Output)
ğŸ‘‰ Save as: python_async_basics_demo.py
import asyncio
import time

async def fetch_data(name, delay):
    print(f"{name} started")
    await asyncio.sleep(delay)
    print(f"{name} finished")

async def main():
    start = time.time()

    await asyncio.gather(
        fetch_data("Task A", 2),
        fetch_data("Task B", 2)
    )

    print(f"Total time: {time.time() - start:.2f}s")

asyncio.run(main())

âœ… Output
Task A started
Task B started
Task A finished
Task B finished
Total time: 2.00s