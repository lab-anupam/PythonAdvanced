1ï¸âƒ£ How Python Actually Works (Internals â€“ Simplified but Accurate)
Key idea (VERY important):

Everything in Python is an object
Variables do not store values â€” they store references (pointers) to objects in memory.

a = 10
b = a


Memory view:

a â”€â”
   â”œâ”€â”€> 10 (int object)
b â”€â”˜


a and b point to the same object

Integers are immutable, so this is safe

id() â†’ Memory Identity
a = 10
b = 10

print(id(a) == id(b))  # True (due to interning)


âš ï¸ Python interns small integers (-5 to 256) for performance.

2ï¸âƒ£ Mutability vs Immutability (Core Concept)
Immutable Objects (âŒ cannot change in-place)

int

float

bool

str

tuple

frozenset

x = 10
x = x + 1   # creates NEW object

Mutable Objects (âœ… can change in-place)

list

dict

set

bytearray

custom objects

lst = [1, 2, 3]
lst.append(4)   # same object modified

3ï¸âƒ£ The Most Common Interview Trap ğŸš¨
Example 1: Lists
a = [1, 2, 3]
b = a

b.append(4)
print(a)  # [1, 2, 3, 4]


Why?

a and b point to the same list

Correct Way (Copy)
a = [1, 2, 3]
b = a.copy()

b.append(4)
print(a)  # [1, 2, 3]

4ï¸âƒ£ Shallow Copy vs Deep Copy (VERY IMPORTANT)
Shallow Copy
import copy

a = [[1, 2], [3, 4]]
b = copy.copy(a)

b[0].append(99)
print(a)  # [[1, 2, 99], [3, 4]]


Why?

Outer list copied

Inner lists still shared

Deep Copy
b = copy.deepcopy(a)

b[0].append(99)
print(a)  # unchanged

Visual Understanding
Shallow Copy:
a â”€â”€> [ L1, L2 ]
b â”€â”€> [ L1, L2 ]   (same inner objects)

Deep Copy:
a â”€â”€> [ L1, L2 ]
b â”€â”€> [ L1', L2' ]

5ï¸âƒ£ Mutability in Function Arguments (CRITICAL)
Mutable Argument Example
def add_item(lst):
    lst.append(100)

nums = [1, 2, 3]
add_item(nums)

print(nums)  # [1, 2, 3, 100]


âœ”ï¸ The function modifies the original list.

Immutable Argument Example
def add_one(x):
    x += 1

a = 10
add_one(a)

print(a)  # 10


âŒ No change â€” integers are immutable.

6ï¸âƒ£ The Famous Python Bug âš ï¸ (DEFAULT MUTABLE ARGUMENT)
def add_item(item, lst=[]):
    lst.append(item)
    return lst

print(add_item(1))
print(add_item(2))


Output:

[1]
[1, 2]  # ğŸ˜± unexpected

Why?

Default arguments are evaluated once, not per call.

Correct Pattern (ALWAYS USE THIS)
def add_item(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst


âœ”ï¸ Interview-safe code

7ï¸âƒ£ Strings vs Lists (Why strings behave â€œweirdâ€)
s = "hello"
s += "!"
print(s)


â¡ï¸ New string created

lst = ["h", "e"]
lst += ["l"]


â¡ï¸ Same list modified

8ï¸âƒ£ Tuples: Immutableâ€¦ but Not Always Safe ğŸ‘€
t = ([1, 2], [3, 4])
t[0].append(99)

print(t)  # ([1, 2, 99], [3, 4])


Tuple is immutable

Contents may be mutable

âš ï¸ This is a common interview question

9ï¸âƒ£ How Python Decides: Modify or Create New Object

Rule of thumb:

Operation	Mutable	Immutable
+=	modifies	creates new
.append()	modifies	âŒ
reassignment	new object	new object
ğŸ”Ÿ Must-Know Summary (MEMORIZE THIS)

âœ… Variables = references
âœ… Mutability controls in-place modification
âœ… Lists/dicts are dangerous when shared
âœ… Shallow vs deep copy matters
âœ… Never use mutable default arguments
âœ… Functions receive object references