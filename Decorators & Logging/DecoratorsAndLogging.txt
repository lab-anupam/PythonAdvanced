ğŸ§  STEP 0: The ONE idea you must understand

ğŸ‘‰ Functions are just variables

Thatâ€™s it.
Everything else builds on this.

STEP 1ï¸âƒ£ Functions are VARIABLES
def hello():
    print("Hello")


Now this:

x = hello
x()

âœ… Output
Hello


ğŸ’¡ Meaning:

hello is a value

x now points to the same function

STEP 2ï¸âƒ£ Functions can be PASSED to other functions
def greet(func):
    func()

def say_hi():
    print("Hi")

greet(say_hi)

âœ… Output
Hi


ğŸ’¡ Meaning:

say_hi is passed without ()

greet calls it

STEP 3ï¸âƒ£ Functions can be RETURNED from functions
def outer():
    def inner():
        print("Inside inner")
    return inner

f = outer()
f()

âœ… Output
Inside inner


ğŸ’¡ Meaning:

outer() returns a function

That returned function is called later

ğŸš¨ This is the core of decorators

ğŸ§  STEP 4: What is a decorator REALLY?

A decorator is just:

A function that
takes a function
returns a new function

STEP 5ï¸âƒ£ A decorator WITHOUT syntax sugar
def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

def hello():
    print("Hello")


Apply decorator manually:

hello = my_decorator(hello)
hello()

âœ… Output
Before function
Hello
After function


ğŸ’¡ Meaning:

hello is replaced

Extra behavior is wrapped around it

STEP 6ï¸âƒ£ The @ symbol is JUST shortcut syntax

This:

@my_decorator
def hello():
    print("Hello")


is EXACTLY the same as:

def hello():
    print("Hello")

hello = my_decorator(hello)


ğŸ“Œ No magic. Just syntax sugar.

ğŸ§  STEP 7: Decorator with function arguments
âŒ Broken decorator
def deco(func):
    def wrapper():
        func()
    return wrapper


This breaks if function has arguments.

âœ… Correct decorator
def deco(func):
    def wrapper(*args, **kwargs):
        print("Calling function")
        return func(*args, **kwargs)
    return wrapper

Example
@deco
def add(a, b):
    return a + b

print(add(2, 3))

âœ… Output
Calling function
5

STEP 8ï¸âƒ£ Why *args, **kwargs?

Because you donâ€™t know:

how many arguments

which keyword arguments

It makes decorator generic.

ğŸ§  STEP 9: Logging decorator (REAL SIMPLE)
def log(func):
    def wrapper(*args, **kwargs):
        print("Function started")
        result = func(*args, **kwargs)
        print("Function finished")
        return result
    return wrapper

@log
def greet(name):
    print("Hello", name)

greet("Anupam")

âœ… Output
Function started
Hello Anupam
Function finished

ğŸ§  STEP ğŸ”Ÿ Timing decorator (SUPER BASIC)
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print("Time:", end - start)
        return result
    return wrapper

@timer
def slow():
    time.sleep(1)

slow()

âœ… Output
Time: 1.00xxxx

ğŸ§  STEP 11: Why functools.wraps (donâ€™t panic)

Without it:

print(slow.__name__)


âŒ Output:

wrapper


Thatâ€™s bad.

Fix:
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        ...
    return wrapper


Now:

print(slow.__name__)


âœ… Output:

slow

ğŸ§  STEP 12: Decorators in ONE SENTENCE

Decorators add behavior to functions
without modifying their code

ğŸ§  STEP 13: Mental Picture (IMPORTANT)
you call greet()
     â†“
wrapper() runs
     â†“
real greet() runs
     â†“
wrapper() finishes


1ï¸âƒ£ What are *args and **kwargs?
ğŸ”¹ *args (Arguments)

Collects positional arguments

Stored as a tuple

Example
def demo(*args):
    print(args)

demo(1, 2, 3)

âœ… Output
(1, 2, 3)


ğŸ’¡ Meaning:
All positional values go into args.

ğŸ”¹ **kwargs (Keyword Arguments)

Collects named arguments

Stored as a dictionary

Example
def demo(**kwargs):
    print(kwargs)

demo(a=1, b=2)

âœ… Output
{'a': 1, 'b': 2}

ğŸ”¥ Together (*args, **kwargs)
def demo(*args, **kwargs):
    print(args)
    print(kwargs)

demo(1, 2, x=10, y=20)

âœ… Output
(1, 2)
{'x': 10, 'y': 20}

ğŸ§  WHY decorators need them

Because decorators must work with ANY function, like:

def f1(a): ...
def f2(a, b): ...
def f3(a, b, c=10): ...


Decorator does not know function signature beforehand.

2ï¸âƒ£ â€œI did not call log â€“ so why is it running?â€

This is the MOST IMPORTANT decorator concept.
Letâ€™s break it line by line.

Your code (simplified)
def log(func):
    def wrapper(*args, **kwargs):
        print("Function started")
        result = func(*args, **kwargs)
        print("Function finished")
        return result
    return wrapper

@log
def greet(name):
    print("Hello", name)

greet("Anupam")

3ï¸âƒ£ What @log REALLY does (NO MAGIC)

This line:

@log
def greet(name):
    print("Hello", name)


Python rewrites it as:

def greet(name):
    print("Hello", name)

greet = log(greet)


ğŸš¨ THIS is the key line.

Step-by-step execution
STEP 1ï¸âƒ£ Python defines greet
def greet(name):
    print("Hello", name)


Nothing printed yet.

STEP 2ï¸âƒ£ Python applies decorator
greet = log(greet)


log(greet) is CALLED once

It returns wrapper

greet now points to wrapper

So now:

greet === wrapper

STEP 3ï¸âƒ£ You call greet("Anupam")

But remember:

greet â†’ wrapper


So Python runs:

wrapper("Anupam")

STEP 4ï¸âƒ£ Wrapper executes
print("Function started")
result = func("Anupam")  # func is original greet
print("Function finished")


Which prints:

Function started
Hello Anupam
Function finished


ğŸ¯ Thatâ€™s why log â€œrunsâ€ even though you didnâ€™t call it manually.

4ï¸âƒ£ Visual Flow (THIS MAKES IT CLICK)
You call greet("Anupam")
        â†“
wrapper("Anupam")   â† greet was replaced
        â†“
print("Function started")
        â†“
original greet("Anupam")
        â†“
print("Hello Anupam")
        â†“
print("Function finished")

5ï¸âƒ£ What is stored where?
Name	What it contains
func	original greet
wrapper	new function
greet	points to wrapper
6ï¸âƒ£ Why not call func() directly?

Because:

You want extra behavior

You want reuse

You want separation of concerns

7ï¸âƒ£ One-sentence summary (MEMORIZE THIS)

@log replaces greet with wrapper, so calling greet() actually calls wrapper().

8ï¸âƒ£ VERY SMALL TEST (try this mentally)
print(greet.__name__)


âŒ Output:

wrapper


Because greet is wrapper now.

ğŸ§  Short answer (in one line)

@wraps copies metadata (name, docstring, etc.) from the original function to the wrapper.

Without it, Python forgets who the original function was.

1ï¸âƒ£ Letâ€™s see the PROBLEM first (no wraps)
Code
def log(func):
    def wrapper(*args, **kwargs):
        print("Start")
        return func(*args, **kwargs)
    return wrapper

@log
def greet(name):
    """Say hello to a user"""
    print("Hello", name)

print(greet.__name__)
print(greet.__doc__)

âŒ Output
wrapper
None


ğŸš¨ What went wrong?

greet lost its name

greet lost its docstring

Because:

greet = wrapper

2ï¸âƒ£ Why this is BAD (real reasons)
âŒ 1. Debugging becomes confusing

Logs show:

Calling wrapper()


instead of:

Calling greet()

âŒ 2. Documentation tools break

Tools like:

help()

Sphinx

IDE tooltips

All rely on:

__name__
__doc__

âŒ 3. Multiple decorators become impossible to trace

Without wraps, all functions become:

wrapper
wrapper
wrapper


You lose the function chain.

3ï¸âƒ£ Now apply @wraps (SLOWLY)
Correct code
from functools import wraps

def log(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Start")
        return func(*args, **kwargs)
    return wrapper

Run the SAME test
@log
def greet(name):
    """Say hello to a user"""
    print("Hello", name)

print(greet.__name__)
print(greet.__doc__)

âœ… Output
greet
Say hello to a user


ğŸ¯ Metadata restored.

4ï¸âƒ£ What @wraps(func) ACTUALLY does

Internally, it copies:

__name__

__doc__

__module__

__annotations__

from func â†’ wrapper

So the wrapper pretends to be the original function.

5ï¸âƒ£ Why YOU personally should care

You might think:

â€œIâ€™m just learning, why bother?â€

But:

You already use logging

You will use decorators in pipelines

You will debug production code

Without wraps, logs look like garbage.

6ï¸âƒ£ Think of it like this (analogy)

func = original person

wrapper = person wearing a mask

@wraps = gives wrapper the original ID card

So everyone still knows who it is.

7ï¸âƒ£ Interview-level explanation (use this)

functools.wraps preserves the original functionâ€™s metadata when itâ€™s wrapped by a decorator, which is critical for debugging, logging, documentation, and introspection.

8ï¸âƒ£ One-line rule (MEMORIZE)

If you write a decorator, always use @wraps.

No exceptions.

9ï¸âƒ£ Final tiny example (cement it)
@log
def add(a, b):
    """Adds two numbers"""
    return a + b

help(add)


âŒ Without wraps â†’ shows wrapper
âœ… With wraps â†’ shows add
