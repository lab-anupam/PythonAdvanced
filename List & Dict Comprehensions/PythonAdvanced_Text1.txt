1ï¸âƒ£ Core Concept (What & Why)

Comprehensions are:

A compact syntax to create collections

Faster than equivalent loops (due to C-level optimizations)

More expressive and readable when used correctly

Basic Equivalence
# Normal loop
result = []
for x in range(10):
    result.append(x * 2)

# List comprehension
result = [x * 2 for x in range(10)]

2ï¸âƒ£ List Comprehensions â€” Patterns You MUST Know
ðŸ”¹ Pattern 1: Simple Mapping

Transform each element.

nums = [1, 2, 3, 4]
squares = [n ** 2 for n in nums]


ðŸ“Œ Used in: feature creation, preprocessing

ðŸ”¹ Pattern 2: Filtering (if condition)
evens = [n for n in range(10) if n % 2 == 0]


âœ” Condition comes after the for

ðŸ”¹ Pattern 3: ifâ€“else (Ternary inside comprehension)
labels = ["even" if n % 2 == 0 else "odd" for n in range(5)]


âš ï¸ Common mistake:

# âŒ invalid
["even" for n in range(5) if n % 2 == 0 else "odd"]

ðŸ”¹ Pattern 4: Nested Loops
pairs = [(i, j) for i in range(3) for j in range(2)]


Equivalent to:

pairs = []
for i in range(3):
    for j in range(2):
        pairs.append((i, j))


ðŸ“Œ Order matters!

ðŸ”¹ Pattern 5: Flattening a List
matrix = [[1, 2], [3, 4], [5, 6]]
flat = [x for row in matrix for x in row]


Very common in data pipelines

3ï¸âƒ£ Dict Comprehensions â€” Patterns You MUST Know
ðŸ”¹ Pattern 1: Keyâ€“Value Mapping
squares = {n: n ** 2 for n in range(5)}

ðŸ”¹ Pattern 2: Filtering Dicts
scores = {"A": 90, "B": 75, "C": 40}
passed = {k: v for k, v in scores.items() if v >= 60}

ðŸ”¹ Pattern 3: Key Transformation
data = {"Name": "Anupam", "Age": 30}
lower_keys = {k.lower(): v for k, v in data.items()}


ðŸ“Œ Very common in JSON normalization

ðŸ”¹ Pattern 4: Swapping Keys & Values
mapping = {"a": 1, "b": 2}
reversed_map = {v: k for k, v in mapping.items()}


âš ï¸ Values must be hashable and unique

4ï¸âƒ£ Set Comprehensions (Quick but Important)
nums = [1, 2, 2, 3, 3, 4]
unique_squares = {n ** 2 for n in nums}


ðŸ“Œ Used to remove duplicates efficiently

5ï¸âƒ£ Tricky Cases (Interview Favorites âš ï¸)
ðŸ”¥ Case 1: Late Binding Trap
funcs = [lambda: i for i in range(3)]
print([f() for f in funcs])


â“ Output?

ðŸ‘‰ [2, 2, 2]

âœ… Fix:

funcs = [lambda i=i: i for i in range(3)]

ðŸ”¥ Case 2: Comprehension Scope (Python 3+)
x = 10
lst = [x for x in range(5)]
print(x)


âœ… Output:

10


ðŸ“Œ In Python 3, comprehension variables have local scope

ðŸ”¥ Case 3: Dict Overwrite Behavior
data = ["a", "b", "a"]
d = {x: len(x) for x in data}
print(d)


ðŸ‘‰ Output:

{'a': 1, 'b': 1}


ðŸ“Œ Last assignment wins

ðŸ”¥ Case 4: Multiple Conditions
nums = range(20)
res = [n for n in nums if n % 2 == 0 if n % 3 == 0]


Equivalent to:

if n % 2 == 0 and n % 3 == 0

6ï¸âƒ£ Performance Insight (Advanced ðŸ’¡)
# Faster
[x * 2 for x in data]

# Slightly slower
list(map(lambda x: x * 2, data))


ðŸ“Œ Rule of thumb:

Comprehension > map/filter (for readability & speed)

Generator if data is huge

7ï¸âƒ£ When NOT to Use Comprehensions ðŸš«

âŒ Too complex logic
âŒ Multiple nested conditions hurting readability
âŒ Side effects (logging, printing, API calls)

# âŒ Bad practice
[x.append(y) for y in range(10)]

8ï¸âƒ£ Generator Comprehension (Preview)
gen = (x * 2 for x in range(10))


Lazy evaluation

Memory efficient

Used heavily in pipelines

9ï¸âƒ£ Mental Model (Remember This)

Comprehension =

Mapping

Filtering

Optional transformation
ALL in ONE expression

âœ… What you should be able to do now

âœ” Convert loops â†’ comprehensions
âœ” Spot invalid comprehensions
âœ” Predict tricky outputs
âœ” Choose between list / dict / set / generator

Next, we can proceed in this exact sequence (recommended):

1ï¸âƒ£ Predict the Output (10 tricky questions)
2ï¸âƒ£ Debug This (broken comprehensions)
3ï¸âƒ£ Interview-level comprehension questions
4ï¸âƒ£ Prepare python_comprehensions_notes.py
5ï¸âƒ£ One-page Comprehension Cheat Sheet

Say â€œNext â†’ Predict Outputâ€ and weâ€™ll continue ðŸ”¥

Next â†’ Predict Output

Perfect ðŸ”¥
Letâ€™s do Day 2 â†’ Predict the Output (List & Dict Comprehensions)
These are interview-grade, not beginner questions.
âš ï¸ Donâ€™t scroll fast â€” try predicting first, then check.

ðŸ§  Predict the Output â€” Comprehensions
1ï¸âƒ£ Variable Scope (Python 3+)
x = 100
lst = [x for x in range(5)]
print(x)

âœ… Output
100


ðŸ“Œ Comprehension variable x has local scope in Python 3+

2ï¸âƒ£ if vs ifâ€“else Placement
result = [i if i % 2 == 0 else -i for i in range(5)]
print(result)

âœ… Output
[0, -1, 2, -3, 4]


ðŸ“Œ ifâ€“else must be before for

3ï¸âƒ£ Multiple if Conditions
nums = range(20)
res = [n for n in nums if n % 2 == 0 if n % 3 == 0]
print(res)

âœ… Output
[0, 6, 12, 18]


ðŸ“Œ Equivalent to if n % 2 == 0 and n % 3 == 0

4ï¸âƒ£ Nested Loop Order
pairs = [(i, j) for i in range(2) for j in range(3)]
print(pairs)

âœ… Output
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]


ðŸ“Œ Loop order matters

5ï¸âƒ£ Dict Key Overwrite
data = ["apple", "banana", "apple"]
d = {x: len(x) for x in data}
print(d)

âœ… Output
{'apple': 5, 'banana': 6}


ðŸ“Œ Last key wins

6ï¸âƒ£ Truthy / Falsy Filter
values = [0, 1, "", "hi", None, 5]
res = [v for v in values if v]
print(res)

âœ… Output
[1, 'hi', 5]


ðŸ“Œ Filters out falsy values

7ï¸âƒ£ Late Binding (Classic Trap ðŸ”¥)
funcs = [lambda: i for i in range(4)]
print([f() for f in funcs])

âœ… Output
[3, 3, 3, 3]


ðŸ“Œ Lambdas capture variable, not value

âœ… Fix:

funcs = [lambda i=i: i for i in range(4)]

8ï¸âƒ£ Dict with Condition on Values
scores = {"A": 80, "B": 55, "C": 90}
res = {k: "pass" if v >= 60 else "fail" for k, v in scores.items()}
print(res)

âœ… Output
{'A': 'pass', 'B': 'fail', 'C': 'pass'}

9ï¸âƒ£ Flatten + Condition
matrix = [[1, 2], [3, 4], [5, 6]]
res = [x for row in matrix for x in row if x % 2 == 0]
print(res)

âœ… Output
[2, 4, 6]


ðŸ“Œ Condition applies to last variable

ðŸ”Ÿ Set Comprehension Surprise
nums = [1, 2, 2, 3, 3]
res = {n * 2 for n in nums}
print(res)

âœ… Output
{2, 4, 6}


ðŸ“Œ Sets remove duplicates automatically

ðŸ§  Interview Insight

If you can:

Predict #1, #7, #9 confidently
ðŸ‘‰ You are already above average Python dev.

Next recommended step ðŸ”¥

ðŸ‘‰ â€œNext â†’ Debug Thisâ€
Youâ€™ll fix broken comprehensions (real interview style)

or

ðŸ‘‰ â€œNext â†’ Interview Questionsâ€
Conceptual + real-world usage questions

Just say the word ðŸ‘

ðŸ‘‰ â€œNext â†’ Debug Thisâ€

Excellent choice ðŸ”¥
This is where interviewers separate â€œknows syntaxâ€ from â€œunderstands Pythonâ€.

ðŸ› ï¸ Debug This â€” List & Dict Comprehensions

Each example has:

âŒ Broken code

ðŸ§  Why itâ€™s wrong

âœ… Correct version

1ï¸âƒ£ Wrong ifâ€“else Placement (Very Common)
âŒ Broken
res = [x for x in range(10) if x % 2 == 0 else -x]

ðŸ§  Why?

else cannot appear after if filter

âœ… Fix
res = [x if x % 2 == 0 else -x for x in range(10)]

2ï¸âƒ£ Using append() in Comprehension
âŒ Broken
lst = []
[x.append(i) for i in range(5)]

ðŸ§  Why?

append() returns None

Comprehensions should not be used for side effects

âœ… Fix
lst = [i for i in range(5)]


or (if side effects intended â€” still not recommended):

for i in range(5):
    lst.append(i)

3ï¸âƒ£ Dict Comprehension Missing .items()
âŒ Broken
d = {"a": 1, "b": 2}
res = {k: v * 2 for k, v in d}

ðŸ§  Why?

Iterating over dict yields keys only

âœ… Fix
res = {k: v * 2 for k, v in d.items()}

4ï¸âƒ£ Wrong Variable Used in Expression
âŒ Broken
nums = [1, 2, 3]
res = [x * 2 for n in nums]

ðŸ§  Why?

x is not defined

âœ… Fix
res = [n * 2 for n in nums]

5ï¸âƒ£ Nested Loop Order Mistake
âŒ Broken (logic error, not syntax)
pairs = [(i, j) for j in range(3) for i in range(2)]

ðŸ§  Why?

Output order may be unexpected

âœ… Fix (if intent was row-wise)
pairs = [(i, j) for i in range(2) for j in range(3)]


ðŸ“Œ Syntax is valid, logic is wrong â†’ interview favorite

6ï¸âƒ£ Late Binding Bug (Lambda)
âŒ Broken
funcs = [lambda: i for i in range(3)]
print([f() for f in funcs])

ðŸ§  Why?

All lambdas capture the same i

âœ… Fix
funcs = [lambda i=i: i for i in range(3)]

7ï¸âƒ£ Using List Comprehension Instead of Generator
âŒ Broken (Memory issue)
data = [process(x) for x in huge_dataset]

ðŸ§  Why?

Loads everything into memory

âœ… Fix
data = (process(x) for x in huge_dataset)


ðŸ“Œ Especially important in data engineering / AI pipelines

8ï¸âƒ£ Dict Comprehension with Duplicate Keys
âŒ Broken (logical bug)
data = ["ab", "cd", "ef"]
res = {len(x): x for x in data}

ðŸ§  Why?

Keys collide â†’ overwritten silently

âœ… Fix
res = {}
for x in data:
    res.setdefault(len(x), []).append(x)


or:

from collections import defaultdict
res = defaultdict(list)
for x in data:
    res[len(x)].append(x)

9ï¸âƒ£ Filtering on Wrong Variable
âŒ Broken
matrix = [[1, 2], [3, 4]]
res = [x for row in matrix if x % 2 == 0 for x in row]

ðŸ§  Why?

x used before definition

âœ… Fix
res = [x for row in matrix for x in row if x % 2 == 0]

ðŸ”Ÿ Overcomplicated Comprehension (Readability Fail)
âŒ Broken (bad practice)
res = [x if x > 0 else -x if x < 0 else 0 for x in data]

ðŸ§  Why?

Hard to read and maintain

âœ… Fix
res = []
for x in data:
    if x > 0:
        res.append(x)
    elif x < 0:
        res.append(-x)
    else:
        res.append(0)


ðŸ“Œ Readability > cleverness

ðŸ§  Interview Rule to Remember

If you need to explain a comprehension for more than 10 seconds â†’ rewrite it as a loop